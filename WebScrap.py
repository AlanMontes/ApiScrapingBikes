# -*- coding: utf-8 -*-
"""ProyectoTema3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EYLB5R2I6TGD3-UioorLzL32dSVRIoEP

# PROYECTO TEMA 3
## WEBSCRAPING PARA LA COMPRA DE BICICLETAS CON CATALOGO CANYON
### EQUIPO 12
Integrantes:

*   Omar Quiñonez Esparza
*   Yahel Adrian Mendoza Gutierrez
*   Alan Jesus Montes Silva

## OBJETIVO
Realizar un webscraping de dos catalogos de bicicletas, para obtener un dataframe con todos los valores principales de cada bicicleta, donde se aplicarán distintas gráficas que nos den indicios de ¿cuanto dinero necesitamos para una bicicleta profesional promedio?

Bloque que realiza el webscraping de la página de catalogoso canyon
"""

import requests
from bs4 import BeautifulSoup
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# LINKS DE LAS PÁGINAS DE BICICLETAS
page = requests.get('https://www.canyon.com/es-mx/bicicletas-de-montana/?srule=sort_master_availability&searchredirect=false&start=0&sz=96')
page2 = requests.get('https://www.canyon.com/es-mx/bicicletas-de-carretera/?srule=sort_master_availability_in-stock-prio&searchredirect=false&start=0&sz=72')

# Arreglo que guardará todos los nombres de las bicicletas
bikes = []

# Arreglo que guardará todos los precios de las bicicletas
cost = []

# Arreglo que guardará toda la información de las bicicletas
info = []

# Arreglo que guardará la categoría de las bicicletas
categoria = []

# Obtiene las bicicletas, precios e info del primer enlace
soup = BeautifulSoup(page.text, 'html.parser')
bikes_items = soup.find_all('a', class_="productTileDefault__productName link link--noUnderline js-productTileLink xlt-productTileLink")
cost_items = soup.find_all('div', class_="productTile__priceSale")[1:]
info_items = soup.find_all('div', class_="productTileDefault__infoWrapper")

# Agrega la categoría "Bicicleta de Montaña" al arreglo
for _ in range(len(bikes_items)):
    categoria.append("Bicicleta de Montaña")

# Obtiene las bicicletas, precios e info del segundo enlace
soup2 = BeautifulSoup(page2.text, 'html.parser')
bikes_items2 = soup2.find_all('a', class_="productTileDefault__productName link link--noUnderline js-productTileLink xlt-productTileLink")
cost_items2 = soup2.find_all('div', class_="productTile__priceSale")[1:]
info_items2 = soup2.find_all('div', class_="productTileDefault__infoWrapper")

for _ in range(len(bikes_items2)):
    categoria.append("Bicicleta de Ruta")

# Obtiene solo el texto de los nombres, precios e información y los agrega a las listas correspondientes
for item in bikes_items:
    bikes.append(item.text.strip())
for item in bikes_items2:
    bikes.append(item.text.strip())

for item in cost_items:
    cost.append(item.text.strip())
for item in cost_items2:
    cost.append(item.text.strip())

for item in info_items:
    info.append(item.text.strip())
for item in info_items2:
    info.append(item.text.strip())

"""Bloque que genera el dataframe y lo imprime, como podemos observar contamos con 4 columnas que abarca el nombre de la bicicleta, el precio, las especificaciones y la categoria, luego imprimimos el dataframe crudo"""

# Generamos el dataFrame
data = {
    'Bicicleta': bikes,
    'Precio': cost,
    'Especificaciones': info,
    'Categoria': categoria
}
df = pd.DataFrame(data)

#Imprimimos el dataFrame
print(df)

# Escribimos el DataFrame en un archivo CSV
# df.to_csv('bikes_data.csv', index=False, encoding='utf-8-sig')

"""Se trata el dataframe en el campo precio, ya que el dato crudo obtiene la columna precios como tipo string y con valores , y $US que no son valores admitibles para aplicar modelos matematicos, por lo que se eliminan caracteres no deseados y se convierte la columna en valor númerico

"""

#Nuestros valores de precio estan representados en dolares, por lo que necesitamos hacer una conversión
# Se converte la columna 'Precio' a tipo cadena (str)
df['Precio'] = df['Precio'].astype(str)
# Se eliminan los simbolos no númericos
df['Precio'] = df['Precio'].str.replace(r'\s?US\$', '', regex=True)
df['Precio'] = df['Precio'].str.replace(',', '')
#Se convierte a tipo númerico
df['Precio'] = pd.to_numeric(df['Precio'], errors='coerce')

print(df)

"""Distribución de precios de bicicletas"""

#GRAFICA DE HISTOGRAMA
plt.hist(df['Precio'], bins=10, color='skyblue', edgecolor='black')
plt.xlabel('Precio en dolares $')
plt.ylabel('Frecuencia')
plt.title('Distribución de precios de bicicletas')
plt.show()

"""Cantidad de bicicletas de montaña contra de ruta"""

#Se cuentan los valores de cada categoria
plt.bar(df['Categoria'].unique(), df['Categoria'].value_counts(), color='lightgreen')
plt.xlabel('Categoría')
plt.ylabel('Cantidad')
plt.title('Cantidad de bicicletas por categoría')
plt.xticks(rotation=45, ha='right')
plt.show()

"""Distribución de precios según la categoria"""

#Para esto usaremos una grafica de caja y bigote donde relacionaremos la categoria con sus precios
plt.figure(figsize=(10, 6))
plt.boxplot([df[df['Categoria'] == cat]['Precio'] for cat in df['Categoria'].unique()],
            labels=df['Categoria'].unique())
plt.xlabel('Categoría')
plt.ylabel('Precio en dolares $')
plt.title('Distribución de precios por categoría')
plt.xticks(rotation=45, ha='right')
plt.show()

"""Grafico que representa la distribución de los precios"""

# Crear el gráfico de dispersión
plt.scatter(df['Bicicleta'], df['Precio'], alpha=0.5)
plt.title('Dispersión de precios')
plt.xlabel('Bicicletas')
plt.ylabel('Precio en dolares $')
plt.grid(True)
plt.xticks([])
# Mostrar el gráfico
plt.show()

"""Campana de Gauss que muestra los valores atipicos de los precios"""

#Libreria para calculso estadistico
from scipy.stats import norm



#Se obtiene la distribución normal de los precios
mu, sigma = norm.fit(df['Precio'])

# Se obtienen los valores necesarios para la campana
xmin, xmax = min(df['Precio']), max(df['Precio'])
x = np.linspace(xmin, xmax, 100)
p = norm.pdf(x, mu, sigma)

# Se crea el grafico
plt.plot(x, p, 'k', linewidth=2)
plt.title('Campana de Gauss de Precios de Bicicletas')
plt.xlabel('Precio en dolares $')
plt.ylabel('Densidad de Probabilidad')
plt.grid(True)
plt.show()